import * as chokidar from 'chokidar';
import * as fs from 'fs';
import * as path from 'path';

const BACKEND_TYPES_PATH = path.join(__dirname, '../src/types/index.ts');
const FRONTEND_TYPES_PATH = path.join(
  __dirname,
  '../../frontend/app/types/api.ts'
);

interface SyncOptions {
  watch?: boolean;
  validate?: boolean;
}

class TypeSyncer {
  private lastSyncTime: Date | null = null;

  validateTypes(content: string): boolean {
    // Basic validation - check if content has type definitions
    const hasTypes =
      content.includes('export type') || content.includes('export interface');
    const hasPrismaImport = content.includes(
      "import { Prisma } from '@prisma/client'"
    );

    if (!hasTypes) {
      console.warn('âš ï¸  Warning: No type definitions found');
      return false;
    }

    if (!hasPrismaImport) {
      console.warn('âš ï¸  Warning: No Prisma import found');
      return false;
    }

    return true;
  }

  generateFrontendTypes(backendTypes: string): string {
    const header = `// ============================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// ============================================
// This file is automatically generated from backend types
// Source: backend/src/types/index.ts
// Last sync: ${new Date().toISOString()}
// 
// To update these types:
// 1. Edit backend/src/types/index.ts
// 2. Run: npm run sync:types (in backend)
// ============================================

`;

    return header + backendTypes;
  }

  syncTypes(options: SyncOptions = {}): boolean {
    try {
      // Check if backend types file exists
      if (!fs.existsSync(BACKEND_TYPES_PATH)) {
        console.error(`âŒ Backend types file not found: ${BACKEND_TYPES_PATH}`);
        return false;
      }

      // Read backend types
      const backendTypes = fs.readFileSync(BACKEND_TYPES_PATH, 'utf-8');

      // Validate types if requested
      if (options.validate && !this.validateTypes(backendTypes)) {
        console.error('âŒ Type validation failed');
        return false;
      }

      // Generate frontend types
      const frontendTypes = this.generateFrontendTypes(backendTypes);

      // Ensure frontend directory exists
      const frontendTypesDir = path.dirname(FRONTEND_TYPES_PATH);
      if (!fs.existsSync(frontendTypesDir)) {
        fs.mkdirSync(frontendTypesDir, { recursive: true });
        console.log(`ðŸ“ Created directory: ${frontendTypesDir}`);
      }

      // Check if content has changed
      if (fs.existsSync(FRONTEND_TYPES_PATH)) {
        const existingContent = fs.readFileSync(FRONTEND_TYPES_PATH, 'utf-8');
        // Compare without timestamps
        const existingWithoutTimestamp = existingContent.replace(
          /Last sync: .+/,
          ''
        );
        const newWithoutTimestamp = frontendTypes.replace(/Last sync: .+/, '');

        if (existingWithoutTimestamp === newWithoutTimestamp) {
          console.log('â„¹ï¸  Types are already up to date');
          return true;
        }
      }

      // Write to frontend
      fs.writeFileSync(FRONTEND_TYPES_PATH, frontendTypes, 'utf-8');

      this.lastSyncTime = new Date();
      const timestamp = this.lastSyncTime.toLocaleTimeString();

      console.log(`âœ… [${timestamp}] Types synced successfully!`);
      console.log(
        `   From: ${path.relative(process.cwd(), BACKEND_TYPES_PATH)}`
      );
      console.log(
        `   To:   ${path.relative(process.cwd(), FRONTEND_TYPES_PATH)}`
      );

      return true;
    } catch (error) {
      console.error('âŒ Error syncing types:', error);
      return false;
    }
  }

  watch(): void {
    console.log('ðŸ‘€ Watching for type changes...');
    console.log(
      `   Watching: ${path.relative(process.cwd(), BACKEND_TYPES_PATH)}`
    );

    const watcher = chokidar.watch(BACKEND_TYPES_PATH, {
      persistent: true,
      ignoreInitial: false,
    });

    watcher.on('change', () => {
      console.log('\nðŸ”„ Types file changed, syncing...');
      this.syncTypes({ validate: true });
    });

    watcher.on('error', (error) => {
      console.error('âŒ Watcher error:', error);
    });

    // Keep the process running
    process.on('SIGINT', () => {
      console.log('\nðŸ‘‹ Stopping type sync watcher...');
      watcher.close();
      process.exit(0);
    });
  }
}

// CLI interface
const args = process.argv.slice(2);
const syncer = new TypeSyncer();

if (args.includes('--watch') || args.includes('-w')) {
  // Initial sync
  syncer.syncTypes({ validate: true });
  // Start watching
  syncer.watch();
} else {
  // One-time sync
  const success = syncer.syncTypes({ validate: true });
  process.exit(success ? 0 : 1);
}
